DefLang EN


Public Class Main

    Public Class A
    
        Private val As Int := Null
    
        Public Sub Initialize(v As Int)
            val := 8 + v
        End Sub

                
        Public Sub Initialize(v As Int, w As Int, s As String)
            Debug.println(s)
            val := 8 + v * w
        End Sub
        
    
        Public Sub printMe()
            Debug.println("A at " + Debug.addressof(Me) + ", val=" + val)
        End Sub
    
    End Class
    
    Public Class B
        Public v As Int
    End Class
    
    Public Shared Sub tc(c As Class, a As Int)
        Dim o As Object := Cast(c, a)
    End Sub
    
    'pour pallier temporairement au 'literal bug'
    Public Shared Function copyOf(a As Int) As Int
        Dim t As Int
        Return t = a
    End Function
    
    Public Shared Sub burn(o As Utils.LinkedList)
        DefLang FR
        
        Soit i Comme Entier
        
        Pour i := copyOf(1) A 100
            o.addHead(i)
        Suivant
        
        DefLang EN
    End Sub
    
    Public Shared Sub main()

    
        Utils.printTitre("debut des test de la LinkedList")
        
        
        Dim list, list2 As Utils.LinkedList
        
        list.add(5)
        list.add(4)
        list.add(12)
        list.add(45)
        list.add(78)
        list.add(0)
        list.addHead(15)
        list.add(70)
        list.addHead(789)
        
        
        list2.add(1)
        list2.add(2)
        list2.add(3)
        
        burn(list2)
        burn(list)
        
        
        Dim it As Utils.LinkedList.Iterator := Null
       
        Dim i As Int
        
        
        Debug.println("Contenu de la liste list2 :")
        
        For it := list2.begin() To list2.end()
            'Debug.println(" |_ " + Cast(Int, it.val()) )
        Next

        Debug.println("Contenu de la liste list :")
        
        For it := list.begin() To list.end()
            'Debug.println(" |_ " + Cast(Int, it.val()) )
        Next
        
        Debug.println("Renversement de la liste list...")
        list.reverse()
        
        For it := list.begin() To list.end()
            'Debug.println(" |_ " + Cast(Int, it.val()) )
        Next
        
        Debug.println("list += list2")
        'list += list2
        
        For it := list.begin() To list.end()
            'Debug.println(" |_ " + Cast(Int, it.val()) )
        Next
        
        Debug.println("Nombre d'éléments dans list : " + #list)
        Debug.println("Nombre d'éléments dans list2 : " + #list2)
        
        Utils.printTitre("fin des tests")

    End Sub
    
   

End Class















Public Module Utils


    Public Class LinkedList
    
        Private Class Node
            Public next As Node := Null
            Public value As Object := Null
            
            Public Sub Initialize(n As Node, v As Object)
                next := n
                value := v
            End Sub
            
            Public Sub add(n As Node)
                If next Is Null Then
                    next := n
                Else
                    next.add(n)
                End If
            End Sub
            
            
            Public Function reverse(prec As Node) As Node
                Dim n As Node := next
                next := prec

                If n Is Null Then
                    Return Me
                Else
                    Return n.reverse(Me)
                End If
                
            End Function
            
            Public Function size() As Int
                If next Is Null Then
                    Return 1
                Else
                    Return next.size() + 1
                End If
            End Function
        
        End Class
        
        Public Class Iterator
            Private pos As Node := Null
            
            Private Shared end As Iterator := New Iterator(Null)
            
            Public Sub Initialize(n As Node)
                pos := n
            End Sub
            
            Public Operator++() As Iterator
                If pos Is Null Then Return end
                
                If pos.next Is Null Then
                    pos := Null
                    Return end
                Else
                    pos := pos.next
                    Return Me
                End If
            End Operator
            
            Public Operator<=(o As Iterator) As Bool
               Return Not Me.pos Is o.pos
            End Operator
            
            Public Function val() As Object
                If pos Is Null Then
                    Return Null
                Else
                    Return pos.value
                End If
            End Function
            
        End Class
    
        Protected root As Node := Null

        Public Sub add(v As Object)
            Dim n As Node := New Node(Null, v)
            
            If root Is Null Then
                root := n
            Else
                root.add(n)
            End If
            
        End Sub
        
        Public Sub addHead(v As Object)
            root := New Node(root, v)
        End Sub
        
        Public Sub reverse()
            If Not root Is Null Then
                root := root.reverse(Null)
            End If
        End Sub
        
        Public Function size() As Int
            If root Is Null Then
                Return 0
            Else
                Return root.size()
            End If
        End Function
        
        Public Operator #() As Int
            Return size()
        End Operator
        
        Public Operator+=(o As LinkedList) As LinkedList
            Dim it As Iterator := Null
            
            For it := o.begin() To o.end()
                add(it.val())
            Next
            
            Return Me
        End Operator
        
        Public Function begin() As Iterator
            Return New Iterator(root)
        End Function
        
        Public Function end() As Iterator
            Return Iterator.end
        End Function
    
    End Class

    

    Public Shared Sub printTitre(t As String)
        Debug.println(titre(t, 50))
    End Sub
    
    Public Shared Function titre(chaine As String, tailleTotale As Int) As String
    
        If #chaine Mod 2 >= 1 Then
            chaine := chaine + " "
        End If
        
        Dim nbTirets As Int := (tailleTotale - chaine.size()) / 2 - 2
        
        If nbTirets <= 0 Then
            Return chaine
        Else
            Dim tirets As String := "-" * nbTirets
            Return tirets + " " + chaine + " " + tirets
        End If
    
    End Function
    
    
End Module
